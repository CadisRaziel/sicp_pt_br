# Prefácio à Primeira Edição

Um computador é como um violino. Você pode imaginar um novato tentando primeiro um toca-discos e depois um violino. O último, ele diz, soa terrível. Esse é o argumento que ouvimos de nossos humanistas e da maioria de nossos cientistas da computação. Programas de computador são bons, dizem eles, para propósitos particulares, mas não são flexíveis. Nem um violino, nem uma máquina de escrever, até que você aprenda a usá-los.—Marvin Minsky, "Por Que Programar É um Bom Meio Para Expressar Ideias Mal Compreendidas e Formuladas de Forma Descuidada""A Estrutura e Interpretação de Programas de Computador" é a disciplina de nível inicial em ciência da computação no Massachusetts Institute of Technology. É obrigatória para todos os estudantes do MIT que se especializam em engenharia elétrica ou em ciência da computação, como um quarto do "currículo central comum", que também inclui duas disciplinas sobre circuitos e sistemas lineares e uma disciplina sobre o projeto de sistemas digitais. Estamos envolvidos no desenvolvimento desta disciplina desde 1978 e temos ensinado este material em sua forma atual desde o outono de 1980, para um público de 600 a 700 estudantes a cada ano. A maioria desses estudantes teve pouco ou nenhum treinamento formal prévio em computação, embora muitos tenham brincado um pouco com computadores e alguns tenham tido extensa experiência em programação ou projeto de hardware.

Nosso projeto para esta disciplina introdutória de ciência da computação reflete duas grandes preocupações. Primeiro, queremos estabelecer a ideia de que uma linguagem de computador não é apenas uma maneira de fazer um computador realizar operações, mas sim que é um novo meio formal para expressar ideias sobre metodologia. Assim, os programas devem ser escritos para as pessoas lerem e, apenas incidentalmente, para as máquinas executarem. Segundo, acreditamos que o material essencial a ser abordado por uma disciplina neste nível não é a sintaxe de construções particulares de linguagens de programação, nem algoritmos inteligentes para computar funções particulares de forma eficiente, nem mesmo a análise matemática de algoritmos e os fundamentos da computação, mas sim as técnicas usadas para controlar a complexidade intelectual de grandes sistemas de software.

Nosso objetivo é que os estudantes que completam esta disciplina tenham uma boa noção dos elementos de estilo e da estética da programação. Eles devem ter o domínio das principais técnicas para controlar a complexidade em um sistema grande. Eles devem ser capazes de ler um programa de 50 páginas, se estiver escrito em um estilo exemplar. Eles devem saber o que não ler e o que não precisam entender a qualquer momento. Eles devem se sentir seguros ao modificar um programa, mantendo o espírito e o estilo do autor original.

Essas habilidades não são de forma alguma exclusivas da programação de computadores. As técnicas que ensinamos e nas quais nos baseamos são comuns a todo projeto de engenharia. Controlamos a complexidade construindo abstrações que ocultam detalhes quando apropriado. Controlamos a complexidade estabelecendo interfaces convencionais que nos permitem construir sistemas combinando peças padrão e bem compreendidas de forma "misturar e combinar". Controlamos a complexidade estabelecendo novas linguagens para descrever um projeto, cada uma das quais enfatiza aspectos particulares do projeto e desvaloriza outros.

Subjacente à nossa abordagem desta disciplina está nossa convicção de que "ciência da computação" não é uma ciência e que sua importância tem pouco a ver com computadores. A revolução dos computadores é uma revolução na maneira como pensamos e na maneira como expressamos o que pensamos. A essência desta mudança é o surgimento do que pode ser melhor chamado de epistemologia procedural — o estudo da estrutura do conhecimento a partir de um ponto de vista imperativo, em oposição ao ponto de vista mais declarativo adotado pelas disciplinas matemáticas clássicas. A Matemática fornece uma estrutura para lidar precisamente com noções de "o que é". A Computação fornece uma estrutura para lidar precisamente com noções de "como fazer".

Ao ensinar nosso material, usamos um dialeto da linguagem de programação Lisp. Nunca ensinamos formalmente a linguagem, porque não precisamos. Apenas a usamos, e os alunos a aprendem em poucos dias. Esta é uma grande vantagem das linguagens do tipo Lisp: Elas têm muito poucas formas de compor expressões e quase nenhuma estrutura sintática. Todas as propriedades formais podem ser cobertas em uma hora, como as regras do xadrez. Depois de um curto período, esquecemos os detalhes sintáticos da linguagem (porque não há nenhum) e passamos para as questões reais — descobrir o que queremos computar, como decomporemos problemas em partes gerenciáveis e como trabalharemos nas partes.

Outra vantagem do Lisp é que ele suporta (mas não impõe) mais das estratégias de larga escala para a decomposição modular de programas do que qualquer outra linguagem que conhecemos. Podemos criar abstrações procedurais e de dados, podemos usar funções de ordem superior para capturar padrões comuns de uso, podemos modelar o estado local usando atribuição e mutação de dados, podemos vincular partes de um programa com streams (fluxos) e avaliação atrasada, e podemos implementar facilmente linguagens embutidas. Tudo isso está incorporado em um ambiente interativo com excelente suporte para design, construção, teste e depuração de programas de forma incremental. Agradecemos a todas as gerações de magos do Lisp, começando com John McCarthy, que criaram uma excelente ferramenta de poder e elegância sem precedentes.

Scheme, o dialeto de Lisp que usamos, é uma tentativa de unir o poder e a elegância de Lisp e Algol. De Lisp, tiramos o poder metalinguístico que deriva da sintaxe simples, da representação uniforme de programas como objetos de dados e dos dados alocados no heap com coleta de lixo. De Algol, tiramos o escopo lexical e a estrutura de blocos, que são presentes dos pioneiros do projeto de linguagens de programação que estavam no comitê Algol. Gostaríamos de citar John Reynolds e Peter Landin por suas percepções sobre a relação do $\lambda$-cálculo de Church com a estrutura das linguagens de programação. Também reconhecemos nossa dívida com os matemáticos que exploraram este território décadas antes de os computadores surgirem em cena. Esses pioneiros incluem Alonzo Church, Barkley Rosser, Stephen Kleene e Haskell Curry.