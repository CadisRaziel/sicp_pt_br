# Construindo Abstrações com Procedimentos
 
Os atos da mente, nos quais ela exerce seu poder sobre ideias simples, são principalmente estes três: 1. Combinar várias ideias simples em uma complexa, e assim todas as ideias complexas são feitas. 2. O segundo é trazer duas ideias, sejam elas simples ou complexas, e colocá-las lado a lado para que se possa ter uma visão delas de uma só vez, sem uni-las em uma, pelo que se obtém todas as suas ideias de relações. 3. O terceiro é separá-las de todas as outras ideias que as acompanham em sua existência real: isto é chamado de abstração, e assim todas as suas ideias gerais são feitas.

—John Locke, Um Ensaio Sobre o Entendimento Humano (1690)

Estamos prestes a estudar a ideia de um processo computacional.

Os processos computacionais são seres abstratos que habitam os computadores. À medida que evoluem, os processos manipulam outras coisas abstratas chamadas dados. A evolução de um processo é dirigida por um padrão de regras chamado programa. Pessoas criam programas para direcionar processos. Na verdade, evocamos os espíritos do computador com nossos feitiços.

Um processo computacional é, de fato, muito parecido com a ideia de um espírito para um feiticeiro. Ele não pode ser visto nem tocado. Não é composto de matéria de forma alguma. No entanto, é muito real. Ele pode realizar trabalho intelectual. Pode responder a perguntas. Pode afetar o mundo desembolsando dinheiro em um banco ou controlando um braço robótico em uma fábrica. Os programas que usamos para evocar processos são como os feitiços de um feiticeiro. Eles são cuidadosamente compostos a partir de expressões simbólicas em linguagens de programação arcanas e esotéricas que prescrevem as tarefas que queremos que nossos processos realizem.

Um processo computacional, em um computador que funciona corretamente, executa programas com precisão e exatidão. Assim, como o aprendiz de feiticeiro, os programadores novatos devem aprender a entender e a antecipar as consequências de sua conjuração. Mesmo pequenos erros (geralmente chamados de bugs ou falhas) nos programas podem ter consequências complexas e inesperadas.

Felizmente, aprender a programar é consideravelmente menos perigoso do que aprender feitiçaria, porque os espíritos com os quais lidamos estão convenientemente contidos de forma segura. A programação no mundo real, no entanto, exige cuidado, expertise e sabedoria. Um pequeno bug em um programa de projeto assistido por computador, por exemplo, pode levar ao colapso catastrófico de um avião ou de uma barragem, ou à autodestruição de um robô industrial.

Engenheiros de software mestres têm a capacidade de organizar programas para que possam ter uma certeza razoável de que os processos resultantes realizarão as tarefas pretendidas. Eles podem visualizar o comportamento de seus sistemas antecipadamente. Eles sabem como estruturar programas para que problemas inesperados não levem a consequências catastróficas e, quando surgem problemas, eles podem depurar seus programas. Sistemas computacionais bem projetados, como automóveis ou reatores nucleares bem projetados, são concebidos de forma modular, para que as partes possam ser construídas, substituídas e depuradas separadamente.

Programando em Lisp
Precisamos de uma linguagem apropriada para descrever processos, e usaremos para esse propósito a linguagem de programação Lisp. Assim como nossos pensamentos cotidianos são geralmente expressos em nossa linguagem natural (como inglês, francês ou japonês), e as descrições de fenômenos quantitativos são expressas com notações matemáticas, nossos pensamentos procedurais serão expressos em Lisp.

Lisp foi inventada no final dos anos 1950 como um formalismo para raciocinar sobre o uso de certos tipos de expressões lógicas, chamadas equações de recursão, como modelo para a computação. A linguagem foi concebida por John McCarthy e é baseada em seu artigo "Recursive Functions of Symbolic Expressions and Their Computation by Machine" (McCarthy 1960).

Apesar de seu início como um formalismo matemático, Lisp é uma linguagem de programação prática. Um interpretador Lisp é uma máquina que executa processos descritos na linguagem Lisp. O primeiro interpretador Lisp foi implementado por McCarthy com a ajuda de colegas e estudantes no Grupo de Inteligência Artificial do Laboratório de Pesquisa de Eletrônica do MIT e no Centro de Computação do MIT. [O Manual do Programador Lisp 1 surgiu em 1960, e o Manual do Programador Lisp 1.5 (McCarthy et al. 1965) foi publicado em 1962. A história inicial do Lisp é descrita em McCarthy 1978.]

Lisp, cujo nome é um acrônimo para LISt Processing (Processamento de Listas), foi projetada para fornecer capacidades de manipulação de símbolos para atacar problemas de programação, como a diferenciação e integração simbólica de expressões algébricas. Incluía para esse propósito novos objetos de dados conhecidos como átomos e listas que mais impressionantemente a diferenciava de todas as outras linguagens da época.

Lisp não foi produto de um esforço de design concentrado. Em vez disso, evoluiu informalmente de maneira experimental em resposta às necessidades dos usuários e a considerações pragmáticas de implementação. A evolução informal do Lisp continuou ao longo dos anos, e a comunidade de usuários do Lisp tradicionalmente resistiu às tentativas de promulgar qualquer definição "oficial" da linguagem. Essa evolução, juntamente com a flexibilidade e elegância da concepção inicial, permitiu que Lisp, que é a segunda linguagem mais antiga em uso difundido hoje (apenas Fortran é mais antiga), se adaptasse continuamente para abranger as ideias mais modernas sobre o projeto de programas. Assim, Lisp é hoje uma família de dialetos, que, embora compartilhem a maioria das características originais, podem diferir uns dos outros de maneiras significativas. O dialeto de Lisp usado neste livro é chamado Scheme.

Os dois dialetos nos quais a maioria dos principais programas Lisp da década de 1970 foi escrita são MacLisp (Moon 1978; Pitman 1983), desenvolvido no MIT Project MAC, e Interlisp (Teitelman 1974), desenvolvido na Bolt Beranek and Newman Inc. e no Xerox Palo Alto Research Center. Portable Standard Lisp (Hearn 1969; Griss 1981) era um dialeto Lisp projetado para ser facilmente portátil entre diferentes máquinas. MacLisp gerou vários subdialetos, como Franz Lisp, que foi desenvolvido na Universidade da Califórnia em Berkeley, e Zetalisp (Moon e Weinreb 1981), que foi baseado em um processador de propósito especial projetado no Laboratório de Inteligência Artificial do MIT para executar Lisp de forma muito eficiente. O dialeto Lisp usado neste livro, chamado Scheme (Steele e Sussman 1975), foi inventado em 1975 por Guy Lewis Steele Jr. e Gerald Jay Sussman do Laboratório de Inteligência Artificial do MIT e posteriormente reimplementado para uso instrucional no MIT. Scheme se tornou um padrão IEEE em 1990 (IEEE 1990). O dialeto Common Lisp (Steele 1982, Steele 1990) foi desenvolvido pela comunidade Lisp para combinar recursos dos dialetos Lisp anteriores para criar um padrão industrial para Lisp. Common Lisp se tornou um padrão ANSI em 1994 (ANSI 1994).

Devido ao seu caráter experimental e sua ênfase na manipulação de símbolos, Lisp foi inicialmente muito ineficiente para cálculos numéricos, pelo menos em comparação com Fortran. Ao longo dos anos, no entanto, compiladores Lisp foram desenvolvidos que traduzem programas para código de máquina que pode realizar cálculos numéricos de forma razoavelmente eficiente. E para aplicações especiais, Lisp tem sido usado com grande eficácia.

Uma dessas aplicações especiais foi um avanço computacional de importância científica — uma integração do movimento do Sistema Solar que estendeu os resultados anteriores em quase duas ordens de magnitude e demonstrou que a dinâmica do Sistema Solar é caótica. Essa computação foi possível graças a novos algoritmos de integração, um compilador de propósito especial e um computador de propósito especial, todos implementados com a ajuda de ferramentas de software escritas em Lisp (Abelson et al. 1992; Sussman e Wisdom 1992).

Embora Lisp ainda não tenha superado sua antiga reputação de ser irremediavelmente ineficiente, Lisp é agora usado em muitas aplicações onde a eficiência não é a preocupação central. Por exemplo, Lisp se tornou uma linguagem de escolha para linguagens de shell de sistemas operacionais e para linguagens de extensão para editores e sistemas de projeto auxiliado por computador.

Se Lisp não é uma linguagem mainstream, por que a estamos usando como base para nossa discussão sobre programação? Porque a linguagem possui características únicas que a tornam um excelente meio para estudar construções e estruturas de dados importantes de programação e para relacioná-las aos recursos linguísticos que as suportam. A mais significativa dessas características é o fato de que as descrições de processos em Lisp, chamadas procedimentos, podem elas próprias ser representadas e manipuladas como dados Lisp.

A importância disso é que existem poderosas técnicas de projeto de programas que dependem da capacidade de esbater a distinção tradicional entre dados "passivos" e processos "ativos". Como descobriremos, a flexibilidade do Lisp no tratamento de procedimentos como dados o torna uma das linguagens mais convenientes existentes para explorar essas técnicas. A capacidade de representar procedimentos como dados também torna Lisp uma excelente linguagem para escrever programas que devem manipular outros programas como dados, como os interpretadores e compiladores que suportam linguagens de computador. Acima e além dessas considerações, programar em Lisp é muito divertido.