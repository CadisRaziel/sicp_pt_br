# Prefácio

Educadores, generais, dentistas, psicólogos e pais programam. Exércitos, estudantes e algumas sociedades são programados. Um ataque a grandes problemas emprega uma sucessão de programas, a maioria dos quais surge durante o percurso. Esses programas estão repletos de questões que parecem particulares ao problema em questão.

Para apreciar a programação como uma atividade intelectual por direito próprio, você deve se voltar para a programação de computadores; você deve ler e escrever programas de computador — muitos deles. Não importa muito sobre o que são os programas ou a quais aplicações eles servem. O que importa é o quão bem eles funcionam e quão suavemente se encaixam com outros programas na criação de programas ainda maiores. O programador deve buscar tanto a perfeição da parte quanto a adequação do conjunto.

Neste livro, o uso de "programa" está focado na criação, execução e estudo de programas escritos em um dialeto de Lisp para execução em um computador digital. Usando Lisp, não restringimos ou limitamos o que podemos programar, mas apenas a notação para as descrições de nossos programas.

Nosso envolvimento com o assunto deste livro nos conecta a três focos de fenômenos: a mente humana, coleções de programas de computador e o computador.

Todo programa de computador é um modelo, incubado na mente, de um processo real ou mental. Esses processos, surgidos da experiência e do pensamento humanos, são imensos em número, intrincados em detalhes e, a qualquer momento, apenas parcialmente compreendidos. Eles raramente são modelados a nossa satisfação permanente por nossos programas de computador. Assim, embora nossos programas sejam coleções discretas de símbolos cuidadosamente elaboradas à mão, mosaicos de funções interligadas, eles evoluem continuamente: nós os mudamos à medida que nossa percepção do modelo se aprofunda, se amplia, se generaliza até que o modelo finalmente atinja um lugar metaestável dentro de outro modelo com o qual lutamos.

A fonte da euforia associada à programação de computadores é o contínuo desdobramento na mente e no computador de mecanismos expressos como programas e a explosão de percepção que eles geram. Se a arte interpreta nossos sonhos, o computador os executa sob o disfarce de programas!

Apesar de todo o seu poder, o computador é um mestre de tarefas rigoroso. Seus programas devem estar corretos, e o que desejamos dizer deve ser dito com precisão em cada detalhe. Como em qualquer outra atividade simbólica, nos convencemos da veracidade do programa através de argumentos. O próprio Lisp pode ter uma semântica atribuída (outro modelo, a propósito) e, se a função de um programa puder ser especificada, digamos, no cálculo de predicados, os métodos de prova da lógica podem ser usados para fazer um argumento aceitável de correção.

Infelizmente, à medida que os programas se tornam grandes e complicados, como quase sempre acontece, a adequação, a consistência e a correção das próprias especificações tornam-se questionáveis, de modo que argumentos formais completos de correção raramente acompanham programas grandes. Uma vez que programas grandes crescem a partir de pequenos, é crucial que desenvolvamos um arsenal de estruturas de programa padrão de cuja correção tenhamos certeza — chamamos isso de idiomas — e aprendamos a combiná-los em estruturas maiores usando técnicas organizacionais de valor comprovado.

Essas técnicas são tratadas longamente neste livro, e compreendê-las é essencial para participar da empresa Prometeica chamada programação. Mais do que qualquer outra coisa, a descoberta e o domínio de poderosas técnicas organizacionais aceleram nossa capacidade de criar programas grandes e significativos. Inversamente, já que escrever programas grandes é muito desgastante, somos estimulados a inventar novos métodos para reduzir a massa de funções e detalhes a serem encaixados em programas grandes.

Ao contrário dos programas, os computadores devem obedecer às leis da física. Se desejam ter um desempenho rápido — alguns nanossegundos por mudança de estado — eles devem transmitir elétrons apenas por pequenas distâncias (no máximo 1,5 pés). O calor gerado pelo grande número de dispositivos tão concentrados no espaço precisa ser removido. Uma arte de engenharia requintada foi desenvolvida, equilibrando a multiplicidade de funções e a densidade de dispositivos.

De qualquer forma, o hardware sempre opera em um nível mais primitivo do que aquele em que nos importamos em programar. Os processos que transformam nossos programas Lisp em programas de "máquina" são eles próprios modelos abstratos que nós programamos. O estudo e a criação deles fornecem uma grande visão sobre os programas organizacionais associados à programação de modelos arbitrários. É claro que o próprio computador pode ser modelado dessa forma. Pense nisso: o comportamento do menor elemento de comutação físico é modelado pela mecânica quântica descrita por equações diferenciais, cujo comportamento detalhado é capturado por aproximações numéricas representadas em programas de computador executados em computadores compostos por . . . !

Não é meramente uma questão de conveniência tática identificar separadamente os três focos. Mesmo que, como dizem, esteja tudo na cabeça, essa separação lógica induz uma aceleração do tráfego simbólico entre esses focos, cuja riqueza, vitalidade e potencial são superados na experiência humana apenas pela própria evolução da vida. Na melhor das hipóteses, as relações entre os focos são metaestáveis. Os computadores nunca são grandes o suficiente ou rápidos o suficiente. Cada avanço na tecnologia de hardware leva a empreendimentos de programação mais maciços, novos princípios organizacionais e um enriquecimento de modelos abstratos. Cada leitor deve se perguntar periodicamente "Para que finalidade, para que finalidade?" — mas não pergunte com muita frequência para não deixar de lado a diversão da programação em favor da constipação da filosofia agridoce.

Entre os programas que escrevemos, alguns (mas nunca o suficiente) executam uma função matemática precisa, como ordenar ou encontrar o máximo de uma sequência de números, determinar a primalidade ou encontrar a raiz quadrada. Chamamos esses programas de algoritmos, e muito se sabe sobre seu comportamento ideal, particularmente em relação aos dois parâmetros importantes de tempo de execução e requisitos de armazenamento de dados. Um programador deve adquirir bons algoritmos e idiomas. Mesmo que alguns programas resistam a especificações precisas, é responsabilidade do programador estimar, e sempre tentar melhorar, seu desempenho.

Lisp é um sobrevivente, estando em uso por cerca de um quarto de século. Entre as linguagens de programação ativas, apenas o Fortran teve uma vida mais longa. Ambas as linguagens suportaram as necessidades de programação de áreas importantes de aplicação, Fortran para computação científica e de engenharia e Lisp para inteligência artificial. Essas duas áreas continuam a ser importantes, e seus programadores são tão dedicados a essas duas linguagens que Lisp e Fortran podem muito bem continuar em uso ativo por pelo menos mais um quarto de século.

Lisp muda. O dialeto Scheme usado neste texto evoluiu do Lisp original e difere deste último de várias maneiras importantes, incluindo o escopo estático para ligação de variáveis e a permissão de funções retornarem funções como valores. Em sua estrutura semântica, Scheme é tão intimamente aparentado com Algol 60 quanto com os Lisps iniciais. Algol 60, que nunca mais será uma linguagem ativa, vive nos genes de Scheme e Pascal.

Seria difícil encontrar duas linguagens que são a moeda comunicante de duas culturas mais diferentes do que as reunidas em torno dessas duas linguagens. Pascal é para construir pirâmides — estruturas estáticas imponentes, de tirar o fôlego, construídas por exércitos empurrando blocos pesados para o lugar. Lisp é para construir organismos — estruturas dinâmicas imponentes, de tirar o fôlego, construídas por esquadrões encaixando miríades flutuantes de organismos mais simples no lugar. Os princípios organizacionais usados são os mesmos em ambos os casos, exceto por uma diferença extraordinariamente importante: A funcionalidade discricionária exportável confiada ao programador Lisp individual é maior em mais de uma ordem de magnitude do que aquela a ser encontrada em empreendimentos Pascal.

Programas Lisp inflam bibliotecas com funções cuja utilidade transcende a aplicação que as produziu. A lista, a estrutura de dados nativa do Lisp, é em grande parte responsável por tal crescimento de utilidade. A estrutura simples e a aplicabilidade natural das listas se refletem em funções que são surpreendentemente não idiossincráticas. Em Pascal, a pletora de estruturas de dados declaráveis induz uma especialização dentro das funções que inibe e penaliza a cooperação casual. É melhor ter 100 funções operando em uma estrutura de dados do que ter 10 funções operando em 10 estruturas de dados. Como resultado, a pirâmide deve permanecer inalterada por um milênio; o organismo deve evoluir ou perecer.

Para ilustrar essa diferença, compare o tratamento do material e dos exercícios neste livro com o de qualquer texto de primeiro curso que use Pascal. Não se iluda que este é um texto digerível apenas no MIT, peculiar à raça encontrada lá. É precisamente o que um livro sério sobre programação Lisp deve ser, não importa quem seja o aluno ou onde seja usado.

Note que este é um texto sobre programação, ao contrário da maioria dos livros Lisp, que são usados como preparação para o trabalho em inteligência artificial. Afinal, as preocupações críticas de programação da engenharia de software e da inteligência artificial tendem a se unir à medida que os sistemas sob investigação se tornam maiores. Isso explica por que há um interesse crescente em Lisp fora da inteligência artificial.

Como seria de esperar de seus objetivos, a pesquisa em inteligência artificial gera muitos problemas de programação significativos. Em outras culturas de programação, esta enxurrada de problemas gera novas linguagens. De fato, em qualquer tarefa de programação muito grande, um princípio organizacional útil é controlar e isolar o tráfego dentro dos módulos de tarefa através da invenção de linguagem. Essas linguagens tendem a se tornar menos primitivas à medida que se aproximam das fronteiras do sistema, onde nós, humanos, interagimos com mais frequência. Como resultado, tais sistemas contêm funções complexas de processamento de linguagem replicadas muitas vezes.

Lisp tem uma sintaxe e semântica tão simples que a análise (parsing) pode ser tratada como uma tarefa elementar. Assim, a tecnologia de análise não desempenha quase nenhum papel em programas Lisp, e a construção de processadores de linguagem raramente é um impedimento para a taxa de crescimento e mudança de grandes sistemas Lisp. Finalmente, é esta própria simplicidade de sintaxe e semântica que é responsável pelo ônus e pela liberdade suportados por todos os programadores Lisp. Nenhum programa Lisp de qualquer tamanho além de algumas linhas pode ser escrito sem estar saturado de funções discricionárias. Invente e encaixe; tenha acessos e reinvente! Saudamos o programador Lisp que escreve seus pensamentos em ninhos de parênteses.

Alan J. Perlis New Haven, Connecticut